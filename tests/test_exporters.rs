use model_generator::primitives::Cube;
use model_generator::{Face, Model, Vertex};
use model_generator::{Rotate, Scale, Translate};
use nalgebra::{Point3, Vector3};
use std::fs;
use std::path::Path;

// Helper function to create a test model
fn create_test_model() -> Model {
    let mut model = Model::new("TestExportModel");

    // Add vertices for a simple pyramid
    let v0 = model.mesh.add_vertex(Vertex::new(
        Point3::new(0.0, 0.0, 0.0),
        Vector3::new(0.0, -1.0, 0.0),
        Some((0.0, 0.0)),
    ));
    let v1 = model.mesh.add_vertex(Vertex::new(
        Point3::new(1.0, 0.0, 0.0),
        Vector3::new(0.0, -1.0, 0.0),
        Some((1.0, 0.0)),
    ));
    let v2 = model.mesh.add_vertex(Vertex::new(
        Point3::new(1.0, 0.0, 1.0),
        Vector3::new(0.0, -1.0, 0.0),
        Some((1.0, 1.0)),
    ));
    let v3 = model.mesh.add_vertex(Vertex::new(
        Point3::new(0.0, 0.0, 1.0),
        Vector3::new(0.0, -1.0, 0.0),
        Some((0.0, 1.0)),
    ));
    let v4 = model.mesh.add_vertex(Vertex::new(
        Point3::new(0.5, 1.0, 0.5),
        Vector3::new(0.0, 1.0, 0.0),
        Some((0.5, 0.5)),
    ));

    // Add faces
    // Base
    model.mesh.add_face(Face::triangle(v0, v1, v2), None);
    model.mesh.add_face(Face::triangle(v0, v2, v3), None);
    // Sides
    model.mesh.add_face(Face::triangle(v0, v4, v1), None);
    model.mesh.add_face(Face::triangle(v1, v4, v2), None);
    model.mesh.add_face(Face::triangle(v2, v4, v3), None);
    model.mesh.add_face(Face::triangle(v3, v4, v0), None);

    model
}

#[test]
fn test_obj_export() {
    let model = create_test_model();
    let export_path = "tests/output/test_export.obj";

    // Create the output directory if it doesn't exist
    if !Path::new("tests/output").exists() {
        fs::create_dir_all("tests/output").unwrap();
    }

    // Export the model
    model.export_obj(export_path).unwrap();

    // Verify the file was created
    assert!(Path::new(export_path).exists());

    // Read the file contents
    let contents = fs::read_to_string(export_path).unwrap();

    // Verify basic content
    assert!(contents.contains("# OBJ file generated by model-generator"));
    assert!(contents.contains("# Model name: TestExportModel"));

    // Verify vertex data
    assert!(contents.contains("v 0 0 0"));
    assert!(contents.contains("v 1 0 0"));
    assert!(contents.contains("v 1 0 1"));
    assert!(contents.contains("v 0 0 1"));
    assert!(contents.contains("v 0.5 1 0.5"));

    // Verify texture coordinates
    assert!(contents.contains("vt 0 0"));
    assert!(contents.contains("vt 1 0"));
    assert!(contents.contains("vt 1 1"));
    assert!(contents.contains("vt 0 1"));
    assert!(contents.contains("vt 0.5 0.5"));

    // Verify normals
    assert!(contents.contains("vn 0 -1 0"));
    assert!(contents.contains("vn 0 1 0"));

    // Verify face data
    assert!(contents.contains("f 1/1/1"));

    // Clean up
    //fs::remove_file(export_path).unwrap();
}

#[test]
fn test_stl_export() {
    let model = create_test_model();
    let export_path = "tests/output/test_export.stl";

    // Create the output directory if it doesn't exist
    if !Path::new("tests/output").exists() {
        fs::create_dir_all("tests/output").unwrap();
    }

    // Export the model
    model.export_stl(export_path).unwrap();

    // Verify the file was created
    assert!(Path::new(export_path).exists());

    // Read the file contents
    let contents = fs::read_to_string(export_path).unwrap();

    // Verify basic content
    assert!(contents.contains("solid TestExportModel"));
    assert!(contents.contains("endsolid TestExportModel"));

    // Verify facet data
    assert!(contents.contains("facet normal"));
    assert!(contents.contains("outer loop"));
    assert!(contents.contains("vertex 0 0 0"));
    assert!(contents.contains("vertex 1 0 0"));
    assert!(contents.contains("vertex 1 0 1"));
    assert!(contents.contains("endloop"));
    assert!(contents.contains("endfacet"));

    // Clean up
    //fs::remove_file(export_path).unwrap();
}

#[test]
fn test_gltf_export() {
    let model = create_test_model();
    let export_path = "tests/output/test_export.gltf";

    // Create the output directory if it doesn't exist
    if !Path::new("tests/output").exists() {
        fs::create_dir_all("tests/output").unwrap();
    }

    // Export the model
    model.export_gltf(export_path).unwrap();

    // Verify the files were created
    assert!(Path::new(export_path).exists());
    assert!(Path::new("tests/output/test_export.bin").exists());

    // Read the file contents
    let contents = fs::read_to_string(export_path).unwrap();

    // Verify basic content
    assert!(contents.contains("\"generator\": \"model-generator\""));
    assert!(contents.contains("\"name\": \"TestExportModel\""));

    // Verify attributes
    assert!(contents.contains("\"POSITION\": 0"));
    assert!(contents.contains("\"NORMAL\": 1"));
    assert!(contents.contains("\"TEXCOORD_0\": 3"));

    // Verify buffer reference
    assert!(contents.contains("\"uri\": \"test_export.bin\""));

    // Clean up
    //fs::remove_file(export_path).unwrap();
    //fs::remove_file("tests/output/test_export.bin").unwrap();
}

#[test]
fn test_export_transformed_model() {
    // Create a cube
    let mut cube = Cube::new().build();

    // Apply transformations
    cube.apply(Scale::uniform(2.0))
        .apply(Rotate::around_y(45.0))
        .apply(Translate::new(1.0, 1.0, 1.0));

    // Create output directory
    if !Path::new("tests/output").exists() {
        fs::create_dir_all("tests/output").unwrap();
    }

    // Export to all formats
    cube.export_obj("tests/output/transformed_cube.obj")
        .unwrap();
    cube.export_stl("tests/output/transformed_cube.stl")
        .unwrap();
    cube.export_gltf("tests/output/transformed_cube.gltf")
        .unwrap();

    // Verify files exist
    assert!(Path::new("tests/output/transformed_cube.obj").exists());
    assert!(Path::new("tests/output/transformed_cube.stl").exists());
    assert!(Path::new("tests/output/transformed_cube.gltf").exists());
    assert!(Path::new("tests/output/transformed_cube.bin").exists());

    // Clean up
    //fs::remove_file("tests/output/transformed_cube.obj").unwrap();
    //fs::remove_file("tests/output/transformed_cube.stl").unwrap();
    //fs::remove_file("tests/output/transformed_cube.gltf").unwrap();
    //fs::remove_file("tests/output/transformed_cube.bin").unwrap();
}
