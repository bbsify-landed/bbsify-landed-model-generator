//! STL file format exporter.

use crate::{Model, Result};
use nalgebra::Vector3;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

/// Export a model to STL format.
///
/// This exports the model as an STL (STereoLithography) file, which is widely
/// supported by 3D printing software, CAD programs, and many 3D modeling applications.
pub fn export_stl<P: AsRef<Path>>(model: &Model, path: P) -> Result<()> {
    // For now we'll implement ASCII STL for simplicity and readability
    // A binary STL exporter could be added for efficiency if needed
    export_ascii_stl(model, path)
}

/// Export a model to ASCII STL format.
fn export_ascii_stl<P: AsRef<Path>>(model: &Model, path: P) -> Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    // Write header
    writeln!(writer, "solid {}", model.name)?;

    // Write each face as a triangle or triangulate non-triangular faces
    for face in &model.mesh.faces {
        match face.indices.len().cmp(&3) {
            std::cmp::Ordering::Less => {
                // Skip degenerate faces
                continue;
            }
            std::cmp::Ordering::Equal => {
                // Simple triangle case
                write_stl_triangle(&mut writer, model, &face.indices)?;
            }
            std::cmp::Ordering::Greater => {
                // Triangulate the face using a simple fan triangulation
                // Note: This works for convex polygons but may not work well for concave ones
                let v0 = face.indices[0];
                for i in 1..face.indices.len() - 1 {
                    let v1 = face.indices[i];
                    let v2 = face.indices[i + 1];
                    write_stl_triangle(&mut writer, model, &[v0, v1, v2])?;
                }
            }
        }
    }

    // Write footer
    writeln!(writer, "endsolid {}", model.name)?;

    Ok(())
}

/// Write a single triangle to the STL file.
fn write_stl_triangle<W: Write>(writer: &mut W, model: &Model, indices: &[usize]) -> Result<()> {
    // Get the vertices
    let v0 = model.mesh.vertices[indices[0]].position;
    let v1 = model.mesh.vertices[indices[1]].position;
    let v2 = model.mesh.vertices[indices[2]].position;

    // Calculate face normal if needed (STL requires normals)
    let normal = calculate_normal(v0, v1, v2);

    // Write the triangle
    writeln!(
        writer,
        "  facet normal {} {} {}",
        normal.x, normal.y, normal.z
    )?;
    writeln!(writer, "    outer loop")?;
    writeln!(writer, "      vertex {} {} {}", v0.x, v0.y, v0.z)?;
    writeln!(writer, "      vertex {} {} {}", v1.x, v1.y, v1.z)?;
    writeln!(writer, "      vertex {} {} {}", v2.x, v2.y, v2.z)?;
    writeln!(writer, "    endloop")?;
    writeln!(writer, "  endfacet")?;

    Ok(())
}

/// Calculate the normal for a triangle.
fn calculate_normal(
    v0: nalgebra::Point3<f32>,
    v1: nalgebra::Point3<f32>,
    v2: nalgebra::Point3<f32>,
) -> Vector3<f32> {
    let edge1 = v1 - v0;
    let edge2 = v2 - v0;
    let normal = edge1.cross(&edge2);

    // Return normalized vector or a default if degenerate
    if normal.magnitude() > 1e-6 {
        normal.normalize()
    } else {
        Vector3::new(0.0, 1.0, 0.0)
    }
}

/// Export a model to binary STL format.
///
/// Binary STL is more compact but less human-readable than ASCII STL.
/// This function is provided for completeness but not currently exposed.
#[allow(dead_code)]
fn export_binary_stl<P: AsRef<Path>>(model: &Model, path: P) -> Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);

    // Header (80 bytes)
    let header = format!(
        "Binary STL generated by model-generator - Model: {}",
        model.name
    );
    let header_bytes = header.as_bytes();
    let header_len = header_bytes.len().min(80);
    let mut full_header = vec![0u8; 80];
    full_header[..header_len].copy_from_slice(&header_bytes[..header_len]);
    writer.write_all(&full_header)?;

    // Count triangles
    let mut triangle_count = 0;
    for face in &model.mesh.faces {
        match face.indices.len().cmp(&3) {
            std::cmp::Ordering::Less => {
                continue;
            }
            std::cmp::Ordering::Equal => {
                triangle_count += 1;
            }
            std::cmp::Ordering::Greater => {
                triangle_count += face.indices.len() - 2;
            }
        }
    }

    // Write triangle count (4 bytes)
    writer.write_all(&(triangle_count as u32).to_le_bytes())?;

    // Write each triangle
    for face in &model.mesh.faces {
        match face.indices.len().cmp(&3) {
            std::cmp::Ordering::Less => {
                // Skip degenerate faces
                continue;
            }
            std::cmp::Ordering::Equal => {
                // Simple triangle case
                write_binary_triangle(&mut writer, model, &face.indices)?;
            }
            std::cmp::Ordering::Greater => {
                // Triangulate the face
                let v0 = face.indices[0];
                for i in 1..face.indices.len() - 1 {
                    let v1 = face.indices[i];
                    let v2 = face.indices[i + 1];
                    write_binary_triangle(&mut writer, model, &[v0, v1, v2])?;
                }
            }
        }
    }

    Ok(())
}

/// Write a single triangle to the binary STL file.
#[allow(dead_code)]
fn write_binary_triangle<W: Write>(writer: &mut W, model: &Model, indices: &[usize]) -> Result<()> {
    // Get the vertices
    let v0 = model.mesh.vertices[indices[0]].position;
    let v1 = model.mesh.vertices[indices[1]].position;
    let v2 = model.mesh.vertices[indices[2]].position;

    // Calculate face normal
    let normal = calculate_normal(v0, v1, v2);

    // Write normal (12 bytes)
    writer.write_all(&normal.x.to_le_bytes())?;
    writer.write_all(&normal.y.to_le_bytes())?;
    writer.write_all(&normal.z.to_le_bytes())?;

    // Write vertices (36 bytes)
    writer.write_all(&v0.x.to_le_bytes())?;
    writer.write_all(&v0.y.to_le_bytes())?;
    writer.write_all(&v0.z.to_le_bytes())?;

    writer.write_all(&v1.x.to_le_bytes())?;
    writer.write_all(&v1.y.to_le_bytes())?;
    writer.write_all(&v1.z.to_le_bytes())?;

    writer.write_all(&v2.x.to_le_bytes())?;
    writer.write_all(&v2.y.to_le_bytes())?;
    writer.write_all(&v2.z.to_le_bytes())?;

    // Attribute byte count (2 bytes) - usually zero
    writer.write_all(&[0, 0])?;

    Ok(())
}
